快速排序算法是一种基于分治思想的排序算法，时间复杂度为O(n(lg(n))
实现原理：
选定序列中的某一值作为基准值，一直维护序列使其存在某一分界点，左侧序列满足小于等于该基准值，右侧序列满足大于等于该基准值，递归处理左右序列，最终使无序序列变为有序序列。
具体实现方法:
void quick_sort(int a[],int l,int r){
    if(l>=r) return ;//当递归序列进行到底时，停止
    int m=l-1,n=r+1;//与下面do while循环相匹配，使停止时指向满足条件的数据
    int x=a[(r+l)>>1];//取中间值不容易使时间复杂度退化
    while(m<n){//判断，当左右指针相遇或是越过时停止，（！注意，越过的情况下，m与n划分区间的关系相反）
        do m++;while(a[m]<x);//维护左序列为<基准值，避免基准值为该序列最大值时，指针越界
        do n--;while(a[n]>x);//与上面同理
        if(m<n) swap(a[m],a[n]);//判断是否需要交换
     }    
        quick_sort(a,l,n);
        quick_sort(a,n+1,r);//当基准数取中间或左边时，递归循环应该不能用[l,n-1]作为划分，当只有两个数据时，左区间会取到空，右区间还是[0,1],导致死循环。
                            //选取n而不是m作为划分是因为，当n越过的时候，m与n的划分关系相反，当m等于n的时候，两者等价，综合考虑应使用n作为划分。
}
